import csv
import lzma
import os
from concurrent.futures import ThreadPoolExecutor

from bulk_update.helper import bulk_update

from jarbas.core.management.commands import LoadCommand
from jarbas.core.models import Reimbursement


class Command(LoadCommand):
    help = 'Load Serenata de Amor irregularities dataset'
    count = 0
    filter_keys = ('applicant_id', 'document_id', 'year')

    def add_arguments(self, parser):
        super().add_arguments(parser, add_drop_all=False)
        parser.add_argument(
            '--batch-size', '-b', dest='batch_size', type=int, default=4096,
            help='Batch size for bulk update (default: 4096)'
        )

    def handle(self, *args, **options):
        self.queue = []
        self.path = options['dataset']
        self.batch_size = options['batch_size']
        if not os.path.exists(self.path):
            raise FileNotFoundError(os.path.abspath(self.path))

        self.main()
        print('{:,} reimbursements updated.'.format(self.count))

    def irregularities(self):
        """Returns a Generator with bathces of irregularities."""
        print('Loading irregularities datasetâ€¦', end='\r')
        with lzma.open(self.path, mode='rt') as file_handler:
            batch = []
            for row in csv.DictReader(file_handler):
                batch.append(self.serialize(row))
                if len(batch) >= self.batch_size:
                    yield batch
                    batch = []
            yield batch

    def serialize(self, row):
        """
        Read the dict generated by DictReader and return a tuple with two
        dictionaries, one to be used as filter to locate the reimbursement,
        another one with data from the irregularities.
        """

        unique_id = dict()
        for key in self.filter_keys:
            unique_id[key] = int(row[key])
            del row[key]

        probability = None
        if 'probability' in row:
            probability = float(row['probability'])
            del row['probability']

        suspicions = {k: self.bool(v) for k, v in row.items() if self.bool(v)}
        if not suspicions:
            suspicions = None

        return unique_id, dict(probability=probability, suspicions=suspicions)

    def main(self):
        for batch in self.irregularities():
            with ThreadPoolExecutor(max_workers=32) as executor:
                executor.map(self.schedule_update, batch)
            self.update()

    def schedule_update(self, unique_id_and_content):
        unique_id, content = unique_id_and_content
        try:
            reimbursement = Reimbursement.objects.get(**unique_id)
        except Reimbursement.DoesNotExist:
            pass
        else:
            reimbursement.suspicions = content.get('suspicions')
            reimbursement.probability = content.get('probability')
            self.queue.append(reimbursement)

    def update(self):
        fields = ['probability', 'suspicions']
        bulk_update(self.queue, update_fields=fields)
        self.count += len(self.queue)
        print('{:,} reimbursements updated.'.format(self.count), end='\r')
        self.queue = []

    @staticmethod
    def bool(string):
        if string.lower() in ('false', '0', '0.0', 'none', 'nil', 'null'):
            string = ''
        return bool(string)
